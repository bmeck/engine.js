#+TITLE: Engine.js

* What is Engine.js?
  Engine.js is a framework for enabling users of your applications to
  write their own javascript code against a (securely) provided set of
  functions or "context". Engine.js is a method of providing javascript
  sandboxing within your own applications.

  Engine.js aims to be both secure and scalable.

  Engine.js currently uses Node.js for script evaluation. It has
  client libraries in Node.js (bundled), Ruby, and PHP.

* Dependencies
   - Linux or OSX
   - Node.js
   - NPM
   - ZeroMQ
     - OS X
       #+begin_src sh
         brew install zeromq
       #+end_src
     - Linux
       - See documentation

* Quick Start
  - Install the library
    #+begin_src sh
      npm install engine.js
    #+end_src
  
  - Start the server
    #+begin_src sh
      node script/server
    #+end_src

  - Write your code
    #+begin_src javascript
      var engine = require("engine");
      client = engine.client.create();
      
      task = client.createTask();
      task.setContext("(function(locals){ return { add: function(a,b){ return a+b } } })");
      task.setLocals({});
      task.setCode('add(1,2)');        
      
      task.on('eval', function(data){
          console.log('your code was evaluated as:', data);
      });
      
      task.run();
      
    #+end_src
  
  - Profit!

* Framework overview
** Components
*** Client 
    The Client allows developers to create Tasks and
    sending them off to the server for evaulation.
    
**** Task
     The Task is the central unit of work. A Task holds:
       1) Context: The global scope that user-code is run against
       2) Code: The user-code to run against the context
       3) Runtime variable bindings: Variable mappings to render within the context

*** Server
**** Intake
     The Intake is responsible for accepting Tasks from many clients
     and fairly distributing across all available Cylinders. 

**** Cylinder
     The Cylinders are responsible for accepting Tasks from the
     Intake, sending tasks to their Piston, and sending Task evaulation
     results to the Exhaust. Every Cylinder has its own Piston.

***** Piston
      The Piston is where the Task is actually evaluated. All Pistons
      run in their own process on the same host as their parent Cylinder.

**** Exhaust
     The Exhaust accepts Task results from all Cylinders and then
     forwards them back to the originating Client.

** Network Topologies
   - Client (n) -> Intake (1)
   - Intake (1) -> Cylinder (n)
   - Cylinder (1) -> Piston (1)
   - Cylinder (1) -> Exhaust (1)
   - Exhaust (1) -> Client (n)

* In the future:
  - Support for other sandboxable scripting languages (ie. Lua)
  - Support other Javascript runtimes (ie. RingoJS)
  - Client's in other languages (Java, Python, etc. Basically any language that has ZeroMQ bindings)
  - Benchmarks
  - Demo applications
